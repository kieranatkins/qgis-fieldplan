from collections import defaultdict

from qgis.PyQt.QtCore import QCoreApplication
from qgis.core import (QgsProcessing,
                       QgsProcessingAlgorithm,
                       QgsProcessingOutputVectorLayer,
                       QgsProcessingParameterVectorLayer,
                       QgsProcessingParameterBoolean,
                       QgsProcessingContext,
                       QgsVectorLayer,
                       QgsField,
                       QgsFields,
                       QgsPointXY,
                       QgsFeature)
from qgis import processing
from qgis.PyQt.QtCore import QMetaType


FIELDS = ['block', 'id', 'row', 'col', 'plot']
LAYER_NAME = 'Field plan - resolved IDs'
INFO="""
Takes field plan generated by the \"Create new field plan\" function and resolves IDs imitating the way a tractor may move
in the field. The function is robust to deletions, and has functionality for row and/or board serpentine ID systems. 
----------\n
Parameters:\n
----------\n
Input field plan - Field plan created by the \"Create new field plan\" function, to have IDs resolved.
Row serpentine - Alternating direction of ordering from row to row. When selected, every row will switch the direction of ID ordering.
Board serpentine - Alternating direction of ordering from board to board. When selected, every board will have a switched direction of ID ordering.
Reverse first board - Decides whether the first board should be flipped or not (i.e. whether the 0-id plot should be near or far from the site edge in the first board).
----------\n
Outputs:\n
----------\n
Field plan - resolved IDs - Copy of the original field plan with two new fields 'resolved_id' and 'resolved_plot'. 'resolved_id' contains the newly-calulated global resolved ID, following.
the given parameters. 'resolved_plot' contains the within-board plot ID in the newly-resolved IDs.
"""

class ResolveIDs(QgsProcessingAlgorithm):
    """
    This is an example algorithm that takes a vector layer,
    creates some new layers and returns some results.
    """

    def tr(self, string):
        """
        Returns a translatable string with the self.tr() function.
        """
        return QCoreApplication.translate('Processing', string)

    def createInstance(self):
        # Must return a new copy of your algorithm.
        return ResolveIDs()

    def name(self):
        """
        Returns the unique algorithm name.
        """
        return 'field_plan_resolve_ids'

    def displayName(self):
        """
        Returns the translated algorithm name.
        """
        return self.tr('Resolve IDs')

    def group(self):
        """
        Returns the name of the group this algorithm belongs to.
        """
        return self.tr('Field plan')

    def groupId(self):
        """
        Returns the unique ID of the group this algorithm belongs
        to.
        """
        return 'fieldplan'

    def shortHelpString(self):
        """
        Returns a localised short help string for the algorithm.
        """
        return self.tr(INFO)

    def initAlgorithm(self, config=None):
        """
        Here we define the inputs and outputs of the algorithm.
        """
        self.addParameter(
            QgsProcessingParameterVectorLayer(
                'INPUT',
                self.tr('Input field plan'),
                types=[QgsProcessing.TypeVectorAnyGeometry]
            )
        )
        self.addParameter(
            QgsProcessingParameterBoolean(
                'ROWSERPENTINE',
                self.tr('Row serpentine'),
            )
        )
        self.addParameter(
            QgsProcessingParameterBoolean(
                'BOARDSERPENTINE',
                self.tr('Board serpentine'),
            )
        )
        self.addParameter(
            QgsProcessingParameterBoolean(
                'REVERSEFIRSTBOARD',
                self.tr('Reverse first board'),
            )
        )
        self.addOutput(
            QgsProcessingOutputVectorLayer(
                'FIELDPLAN',
                self.tr('Output field plan')
            )
        )

    def checkParameterValues(self, parameters, context):
        crs = context.project().crs()
        if crs.isGeographic():
            return False, "The system requires the CRS be geographic (e.g. UTM projection), as the script calculates shapes in metres"
        
        return True, ''

    def processAlgorithm(self, parameters, context, feedback):
        """
        Here is where the processing itself takes place.
        """
        crs = context.project().crs().authid()
        layer = QgsVectorLayer(f"Polygon?crs={crs}", LAYER_NAME, "memory")
        layer.startEditing()
    
        # Setup fields
        provider = layer.dataProvider()
        fields = QgsFields()
        fields.append(QgsField("id", QMetaType.Int))
        fields.append(QgsField("block", QMetaType.Int))
        fields.append(QgsField("row", QMetaType.Int))
        fields.append(QgsField("col", QMetaType.Int))
        fields.append(QgsField("plot", QMetaType.Int))
        fields.append(QgsField("resolved_id", QMetaType.Int))
        fields.append(QgsField("resolved_plot", QMetaType.Int))
        
        provider.addAttributes(fields)
        layer.updateFields()

        input_layer = self.parameterAsVectorLayer(parameters, 'INPUT', context)
        row_serpentine = self.parameterAsBool(parameters, 'ROWSERPENTINE', context)
        board_serpentine = self.parameterAsBool(parameters, 'BOARDSERPENTINE', context)
        reverse_first_board = self.parameterAsBool(parameters, 'REVERSEFIRSTBOARD', context)

        # Get features from input, check they're sorted
        features = list(input_layer.getFeatures())
        features = sorted(features, key=lambda f: f['id'])
        feedback.pushInfo(f'{len(features)} shapes to resolve')
        # maps original identifier to new resolved id
        id_map = {}
        # maps original plot number to a reversed format in the serpentine case
        plot_map = {}

        resolved_id = 1
        board_serpentine_switch = False if reverse_first_board else True
        row_serpentine_switch = True 

        # group records by row and iterate
        rows = defaultdict(list)
        for f in features:
            rows[f['row']].append(f)

        for row in rows.values():
            row = row if row_serpentine_switch else reversed(row)

            # group record rows by block and iterate
            blocks = defaultdict(list)
            for f in row:
                blocks[f['block']].append(f)
            
            for block in blocks.values():
                boards = defaultdict(list)

                # group records by row, block and board then iterate
                for f in block:
                    boards[f['col']].append(f)
                
                for board in boards.values():
                    board = board if board_serpentine_switch else reversed(board)

                    for i, plot in enumerate(board):
                        id_map.update({int(plot['id']):int(resolved_id)})
                        plot_map.update({int(plot['id']):int(i+1)})
                        resolved_id += 1
                    
                    board_serpentine_switch = not board_serpentine_switch if board_serpentine else board_serpentine

            row_serpentine_switch = not row_serpentine_switch if row_serpentine else row_serpentine

        for i, f in enumerate(features):
            f_new = QgsFeature()
            f_new.setGeometry(f.geometry())
            attr = [f['id'], f['block'], f['row'], f['col'], f['plot'], id_map[f['id']], plot_map[f['id']]]
            f_new.setAttributes(attr)
            provider.addFeature(f_new)

        feedback.pushInfo(f'Created {i+1} polygons.')

        layer.commitChanges()
        layer.updateExtents()
        context.temporaryLayerStore().addMapLayer(layer)
        context.addLayerToLoadOnCompletion(layer.id(), QgsProcessingContext.LayerDetails(LAYER_NAME, context.project(), 'FIELDPLAN'))

        feedback.setProgress(100)
        return {'FIELDPLAN':None}